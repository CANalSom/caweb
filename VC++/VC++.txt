< 1주차 요약 > 250826
 ===== Window 시스템 프로그래밍 : Win32 or .NET Framework(win64) =====
 - GUI 프로그램을 작성 : 작성하는 App. 윈도우에 등록한다.
 - CALLBACK 함수 : OS에 프로그램을 등록할 때, OS에게 동시에 전달하ㄴ다.
 - 사용자 입력 -> OS가 해석, 정보 확인 -> 응용 프로그램에 전달(WndProc)
 - 응용 프로그램에 전달할 때는 MSG 형태로 전달
 - WndProc 함수 인수 : 사용자가 입력한 정보를 처리한다.
 - HWND : 사용자가 입력한 윈도우 자체를 가리킨다.
 - UINT : 사용자가 무엇을 입력했는지를 나타냄
 - WPARAM(Word Parameter) : char 자료형, 키보드 입력과 관련된 정보
 - LPARAM(Long Parameter) : int 자료형, 마우스 입력과 관련된 정보


< 2주차 > 250902
[ 화면 그리기]
 - 점 : 좌표 1개 (x, y)
 - 선 : 좌표 2개 (시작점(x, y), 끝점(x', y'))


< 3주차 > 250909
[ 화면 그리기]
 - 윈도우(GUI 환경)에서의 화면 그리기
	1. 화면은 OS의 것이다. 따라서 그리기는 결국 OS에게 요청하는 것이다.
	2. 선, 면(사각형) : 2D 그래픽은 그리는 순서가 가장 아래에 위치한다.
	3. 그리기 요청 API
		3-1. 선 그리기 : MoveToEx( ) - 시작점 설정, LineTo() - 끝점 설정 및 그리기 요청
		3-2. 사각형 그리기 : Rectangle( ) - 2개의 좌표 값을 전달 (left, top, right, bottom)
		3-3. 타원 그리기 : Ellipse( ) - 2개의 좌표 값을 전달

- WM_PAINT
	1. 내부에 구현된 코드를 어떤 상태에서든지 반드시 화면에 출력한다.
	2. 화면의 모든 변경 → WM_PAINT가 호출된다.
		2-1. 창의 크기 조절, 창의 최대화, 창의 최소화, 화면 밖으로 이동
		2-2. 프로그램이 실행된 다음 OS에 의해서 자동적으로 한번 호출
		2-3. 프로그래머의 요청에 의해 OS가 호출해주는 경우

- HDC(Handle Device Context)
	1. 화면에 그리기를 요청할 때, 반드시 필요한 자료 구조
	2. 획득 방법 
		2-1. 획득 방법 1 : WM_PAINT에서 BeginPaint( ) 획득, 해제는 EndPaint( )
		2-2. 획득 방법 2 : WM_PAINT 외에서 GetDC( ) 획득, 해제는 ReleaseDC( )

- 사용자 입력 <마우스>
	1. 마우스 입력
		1-1. WM_L/RBUTTONDOWN, WM_L/RBUTTONUP, WM_MOUSEMOVE
		1-2. H/W 관련된 사용자 입력은 모든 단계가 별도로 구성된다.
		1-3. 단계가 별도로 구성되기 때문에 그때마다 WM가 발생한다.
		1-4. 콜백 함수 : OS가 호출할 수 있는 함수. 일반 함수와 동일하다.
		1-5. 이전에 발생한 콜백에서 정보를 보관하려면 전역 변수를 사용
		1-6. x, y 좌표를 획득하는 방법
			- lParam에서 정보를 획득
			- LOWORD( ) → 매크로 x좌표
			- HIWORD( ) → 매크로 y좌표


< 4주차 > 250916
- 이벤트
	- WM_L/RBUTTONDOWN-UP-MOVE
	- 모든 이벤트는 단독(콜백 함수로 정보 전달)으로 동작한다.
	- 과제 : 마우스를 이용한 자유선 그리기
	- 전역 변수 필요 이유 : 콜백 함수 간의 정보를 유지
	- 플래그 변수 : 일반 변수와 동일. 상태 정보를 갖는다.

- 윈도우 메시지
	- WM_KEYDOWN/UP
	- ASCII 코드로 눌려진 키의 값이 전달되었다.

- 문자열 처리
	- 화면에 그림 대신 글자를 그리는 API
	- 자료형 : WCHAR ( == wchar_t )
	- wsprintf( ) : 선언된 문자열 변수에 지정 형식으로 내용을 채우는 함수
	- TextOut( ) API : 화면에 지정된 문자열을 출력 API
	- lstrlenW( ) : 유니코드 문자열의 정확한 길이를 알려주는 함수

- HDC 이용 API
	- HDC
		- 화면 정보를 보관하는 정보체 - 내용을 알 수는 없다.
		- 화면 그리기에 필요한 정보 포함 - 변경을 요청
		- 변경은 OS에게 요청해서 변경이 발생!
	- 2개의 속성 변경
		- 선 객체의 속성 변경 : 기본 선은 굵기 1px에 검은색
		- 면 객체의 속성 변경 : 기본 면은 하얀색
	- 변경 방법(예 - 선 변경)
		- 선 객체를 생성 → OS에게 선 객체를 전달(API) → 원래 선 객체 반환
		- → 선을 사용 → OS에게 원래 선 객체를 전달

- 과제
	- 간단한 그림판을 만들어 봅시다.
		- 그리기 선택 : 선, 사각형, 타원, 자유선
		- 선 굵기 선택 : 1px, 5px, 10px
		- 선 색상 선택 : 빨간색, 녹색, 파란색
		- 면 색상 선택 : 검은색, 하얀색, 다홍색(200,100,100)

- RECT 자료형
	- 사각형의 좌표 표시를 위해 사용
		- 2개의 좌표 값을 보관하는 자료형
		- left, top : 최상단 x, y 좌표
		- right, bottom : 우하단 x, y 좌표
		- 좌상단, 우하단에 해당하는 x, y 좌표를 정확하게 입력
		typedef struct tagRECT
		{
			LONG	 left;
			LONG top;
			LONG right;
			LONG bottom;
		}

- 게임 만들기
	- 나를 쫓아오고, 도망가고, 음식을 먹는 간단한 게임
	- 나 : 사각형 표시, 내가 이동시킬 수 있는 객체
	- 적 : 타원으로 표시, 자동으로 이동하는 객체
	- 음식 : 타원으로 표시, 화면에 출력

- MVC 모델
	- M : model
	- V : View
	- C : Controller


< 5주차 > 250923
- HDC의 속성 변경
	- API를 이용하여 변경
		- HDC 정보는 직접적으로 접근 불가 → OS에 요청
		- SelectObject( ) API : HDC 객체 정보 변경
		- DeleteObject( ) API : 변경을 위해 생성한 HDC 객체 해제
		- HPEN, HBRUSH 객체들을 생성하여 테스트 진행
		- 변경 순서
			- 1. HDC 객체 생성
			- 2. 객체 변경 요청 (SelectObject)
			- 3. 현재 OS가 사용하는 객체를 반환
			- 4. 사용
			- 5. 객체 변경 요청
			- 6. 객체의 삭제/해제 (DeleteObject)

- RECT 자료형
	- 단순 구조체(정보체)
		- left, top, right, bottom으로 구성된 단순한 형태
		- left, top : 반드시 좌상단의 x, y 좌표로 구성
		- right, bottom : 반드시 우하단의 x, y 좌표로 구성

	- 나의 객체 이동
		- 화면에 나의 객체 정보 표현을 위해 RECT 자료형 사용
		- WM_KEYDOWN에서 키 값을 확인하고, 좌표를 이동
		- 좌/우 이동 : left 또는 right 값을 하나만 변경 → 직사형 형태로 늘어남
		- 이동 시에는 left/right, top/bottom 값은 항상 같이 변경해야 함!

- 표준
	- H/W 장비의 표준화
		- a 키 입력 → 0x76 값이 전달 → OS가 받음 : a/ㅁ
		- OS는 항상 보고 있는 키보드가 별도 존재
		- Callback 함수 호출을 위한 준비
			- 누구한테 전달할 것인지, 호출 준비, 인수 준비 ...
			- Callback 함수를 호출해서 응용 프로그램에 정보를 전달
			- OS가 항상 보고 있는 키보드 : Virtual Keyboard(가상 키보드)
		- OS가 항상 보고 있는 키보드 : Virtual Keyboard(가상 키보드)

- 겹침 확인 API
	- IntersectRect( )
		- 전달 좌표 : 나
		- 상대 좌표 → RECT 자료형이 필수!
		- 반환되는 정보 : 겹침 여부, 겹침 영역
			- 겹쳤다면 겹침이 발생한 영역 정보가 RECT 자료형으로 반환


< 6주차 > 250930
	- 단순 자료형
		- left, top : 좌상단의 좌표
		- right, bottom : 우하단의 좌표
		- 반드시 해당 위치 좌표를 입력해야 정상 동작하는 API가 존재
			- 해당 API를 사용하지 않고도 계산은 가능!
		- 겹침 확인을 위해서는 반드시 RECT 자료형을 사용!!!

	- 겹침 정리 API
		- IntersectRect( ) API
			- OS에게 겹침 발생여부를 확인할 때 사용
			- 2개의 반환 값
				- 겹침이 발생했는지 여부 : TRUE(겹침이 있다.), FALSE(겹침이 없다)
				- 겹침이 발생한 영역에 대한 RECT 자료형 반환
			- BOOL IntersectRect(LPRECT dst, const RECT* src1, const RECT* src2)
				- src1/2 : 겹침을 확인할 RECT 자료형
				- dst : 겹침이 발생. 겹침이 발생한 영역 정보
			
	- 객체 추적
		- 나와 상대
			- 상대가 나를 추적하는 방법
			- 좌표를 이용해서 추적
			- RECT의 좌상단 x, y 좌표 값의 크기를 이용하여 추적
				- 상대가 나를 기준으로 왼/오른쪽에 존재하는지 구분
				- 상대가 나를 기준으로 위/아래에 존재하는지 구분

	- 주기적인 호출
		- OS에게 알람을 요청
			- SetTimer( ) API : 알람 설정. msec 단위로 시간 설정
			- KillTimer( ) API : 알람 해제. SetTimer에서 설정한 ID 값이 필요
			- 알림이 도착하는 윈도우 메시지 : WM_TIMER
			- 알림이 도착했을 때, ID를 구분하기 위한 방법
					→ wParam에 SetTimer의 ID으로 구분
				
	- 게임 기능 만들기
		- 상대에게 겹침 당하면 크기 감소
		- 생명이 5개 존재

		- 음식을 먹으면 상대가 빠르게 쫓아오도록
		- 음식을 특정 개수 먹으면 게임이 종료
		- 음식을 특정 개수 레어 음식을 먹으면 내가 빨라지도록

		- 포탈 : 연결되어 있는 포탈에 들어가면 특정 위치로 이동

	- 음식 레어 만들기
		- a1, a2 값으로 결정
			- a1 : 0 ~ 9 까지의 수로 랜덤 값 획득
				- a1의 값이 8 또는 9라면 1차 랜덤 성공
			- a2 : 0 ~ 3 까지의 수로 랜덤 값 획득
				- a2 == 2라면 레어 음식

	- 게임 기능 만들기
		- 시간 설정 후 음식을 몇 개나 먹었는지 확인
			- 시간 설정 : 추가적인 알림이 필요하다
					: 시간 정보를 시각적으로 확인이 가능해야 한다.
			- 몇 개나 먹었나 : 먹은 개수 카운트
			- 게임 시간 종료 시에 나도 움직이지 않아야 함.
		- 상대 개수 증가
		- 상대의 속도가 갈수록 빨라지도록 구성

	- 게임 과제
		- 일반적인 게임을 작성
		- 그라운드를 벗어나면 안됨
		- 시간 내에만 이동 가능(상대/나 포함)
		- 상대를 반드시 1개 이상 추가할 것
			- 게임 시간이 지난 이후에 둘이 뭉치지 않도록 구성할 것!!!!


